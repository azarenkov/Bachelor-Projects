def runge_kutta_method(f, x0, y0, h, n):
    x = x0
    y = y0

    for i in range(n):
        k1 = h * f(x, y)
        k2 = h * f(x + h / 2, y + k1 / 2)
        k3 = h * f(x + h / 2, y + k2 / 2)
        k4 = h * f(x + h, y + k3)

        y = y + (k1 + 2 * k2 + 2 * k3 + k4) / 6
        x = x + h

    return x, y


def runge_kutta_method_full(f, x0, y0, h, n):
    points = [(x0, y0)]
    x = x0
    y = y0

    for i in range(n):
        k1 = h * f(x, y)
        k2 = h * f(x + h / 2, y + k1 / 2)
        k3 = h * f(x + h / 2, y + k2 / 2)
        k4 = h * f(x + h, y + k3)

        y = y + (k1 + 2 * k2 + 2 * k3 + k4) / 6
        x = x + h
        points.append((x, y))

    return points


if __name__ == "__main__":

    def f(x, y):
        return x + y

    x0, y0 = 0, 1
    h = 0.1
    n = 10

    x_final, y_final = runge_kutta_method(f, x0, y0, h, n)
    print(f"Final point: x = {x_final}, y = {y_final}")

    points = runge_kutta_method_full(f, x0, y0, h, n)
    print("\nAll points:")
    for x, y in points:
        print(f"x = {x:.1f}, y = {y:.6f}")

# Входные данные:
# ├─ f: функция f(x,y) из уравнения y' = f(x,y)
# ├─ x0 = 0, y0 = 1 (начальная точка)
# ├─ h = 0.1 (шаг интегрирования)
# └─ n = 10 (количество шагов)

# Процесс (метод 4-го порядка):
# 1. Начать с (x₀, y₀)
# 2. На каждом шаге i вычислить 4 наклона:
#    k₁ = h·f(xᵢ, yᵢ)              - наклон в начале интервала
#    k₂ = h·f(xᵢ + h/2, yᵢ + k₁/2) - наклон в середине (используя k₁)
#    k₃ = h·f(xᵢ + h/2, yᵢ + k₂/2) - наклон в середине (используя k₂)
#    k₄ = h·f(xᵢ + h, yᵢ + k₃)     - наклон в конце (используя k₃)
# 3. Взвешенное среднее:
#    yᵢ₊₁ = yᵢ + (k₁ + 2k₂ + 2k₃ + k₄)/6
#    xᵢ₊₁ = xᵢ + h
# 4. Повторить n раз

# Результат:
# ├─ runge_kutta_method: конечная точка (x_final, y_final)
# └─ runge_kutta_method_full: все промежуточные точки

# Формулы RK4:
# k₁ = h·f(x, y)
# k₂ = h·f(x + h/2, y + k₁/2)
# k₃ = h·f(x + h/2, y + k₂/2)
# k₄ = h·f(x + h, y + k₃)
# yₙₑₓₜ = y + (k₁ + 2k₂ + 2k₃ + k₄)/6

# Пример для y' = x + y, y(0) = 1, h = 0.1:
# Шаг 0: (x₀, y₀) = (0.0, 1.0)
# Шаг 1:
#   k₁ = 0.1·f(0.0, 1.0) = 0.1·1.0 = 0.1
#   k₂ = 0.1·f(0.05, 1.05) = 0.1·1.1 = 0.11
#   k₃ = 0.1·f(0.05, 1.055) = 0.1·1.105 = 0.1105
#   k₄ = 0.1·f(0.1, 1.1105) = 0.1·1.2105 = 0.12105
#   y₁ = 1.0 + (0.1 + 2·0.11 + 2·0.1105 + 0.12105)/6
#      = 1.0 + 0.66105/6 = 1.0 + 0.110175 = 1.110175
#   (x₁, y₁) = (0.1, 1.110175)
# Шаг 2:
#   k₁ = 0.1·f(0.1, 1.110175) = 0.1·1.210175 = 0.1210175
#   k₂ = 0.1·f(0.15, 1.1706838) = 0.1·1.3206838 = 0.13206838
#   k₃ = 0.1·f(0.15, 1.1762092) = 0.1·1.3262092 = 0.13262092
#   k₄ = 0.1·f(0.2, 1.2427959) = 0.1·1.4427959 = 0.14427959
#   y₂ = 1.110175 + (k₁ + 2k₂ + 2k₃ + k₄)/6 ≈ 1.242806
#   (x₂, y₂) = (0.2, 1.242806)
# ...и так далее до x₁₀ = 1.0

# Геометрическая интерпретация:
# RK4 вычисляет наклоны в 4 точках на интервале [xᵢ, xᵢ+h]:
# - k₁: наклон в начале
# - k₂: наклон в середине (первая оценка)
# - k₃: наклон в середине (уточненная оценка)
# - k₄: наклон в конце
# Использует взвешенное среднее с весами [1, 2, 2, 1],
# что дает среднее значение наклона на всем интервале

# Преимущества:
# - Точность O(h⁴) - четвертого порядка
# - Не требует вычисления производных f(x,y)
# - Самый популярный метод для ОДУ
# - Оптимальный баланс точности и вычислительной сложности
